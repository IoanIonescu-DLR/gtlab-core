/* GTlab - Gas Turbine laboratory
 * Source File: gt_structproperty.h
 * copyright 2009-2016 by DLR
 *
 *  Created on: 28.06.2016
 *  Author: Stanislaus Reitenbach (AT-TW)
 *  Tel.: +49 2203 601 2907
 */

#ifndef GTDYNAMICPROPERTYCONTAINER_H
#define GTDYNAMICPROPERTYCONTAINER_H

#include "gt_datamodel_exports.h"

#include "gt_abstractproperty.h"
#include "gt_groupproperty.h"
#include "gt_polyvector.h"

/**
 * @brief The GtDynamicPropertyContainer class
 */
class GT_DATAMODEL_EXPORT GtDynamicPropertyContainer : public GtAbstractProperty
{
    Q_OBJECT

public:
    /**
     * @brief GtDynamicPropertyContainer
     * @param name
     */
    explicit GtDynamicPropertyContainer(const QString& name);

    /**
     * @brief valueToVariant
     * @return
     */
    QVariant valueToVariant(const QString& unit,
                            bool* success = nullptr) const override;

    /**
     * @brief setValueFromVariant
     * @param val
     * @return
     */
    bool setValueFromVariant(const QVariant& val, const QString& unit,
                             bool* success = nullptr) override;

    /**
     * @brief registerSubProperty
     * @param property
     */
    void registerSubProperty(GtAbstractProperty& property) override;

    /**
     * @brief deleteSubProperty
     * @param property
     */
    virtual void deleteSubProperty(GtAbstractProperty* property);
};


/**
 * @brief This class is similar to a group property and serves
 * as a struct of properties.
 *
 * Compared to GtGroupProperty, a GtPropertyStructInstance own
 * its subproperties.
 *
 * An instance is typically created by calling to
 * GtPropertyStructDefinition::newInstance.
 */
class GtPropertyStructInstance : public GtGroupProperty
{
public:
    GtPropertyStructInstance(const QString& id, const QString& typeName,
                             gt::poly_vector<GtAbstractProperty>&& childProps) :
        GtGroupProperty(typeName, ""),
        m_childs(std::move(childProps))
    {
        m_id = id;

        for (auto& child : m_childs)
        {
            registerSubProperty(child);
        }
    }

    /**
     * @brief Return the (dynamic) type of the struct
     * @return
     */
    QString typeName() const
    {
        return objectName();
    }

private:
    gt::poly_vector<GtAbstractProperty> m_childs;
};


/**
 * @brief This class is used to dynamically define a structure of properties.
 *
 * It can then be used to generate instances of the defined type using
 * the function GtPropertyStructDefinition::newInstance
 */
class GtPropertyStructDefinition
{
public:
    /**
     * @brief GtPropertyStructDefinition
     * @param typeName Type name of the structure (similar to a class name)
     *                 e.g. MyPoint3d
     */
    GT_DATAMODEL_EXPORT
    explicit GtPropertyStructDefinition(QString typeName);


    /**
     * @brief Defines a member variable of the type given 'propertyClassName'
     *
     * Example: struct.defineMember("weight", "GtDoubleProperty", 1.0)
     *
     * propertyClassName needs to be a valid name that is already registered
     * at the property factory.
     *
     * @param id The id of the property, e.g. "weight"
     * @param propertyClassName The class name, e.g. "GtDoubleProperty"
     * @param defaultVal A default value (e.g. 1.0)
     */
    GT_DATAMODEL_EXPORT
    void defineMember(const QString& id,
                      const QString& propertyClassName,
                      QVariant defaultVal);

    /**
     * Function definition to create a property with the
     * identifier 'id'
     */
    using PropertyFactoryFunction =
        std::function<GtAbstractProperty*(const QString& id)>;

    /**
     * @brief Defines a member which will be generated by the function f
     * @param id The id of the property, e.g. "weight"
     * @param f  A function to create the member property
     */
    GT_DATAMODEL_EXPORT
    void defineMember(const QString& id, PropertyFactoryFunction f);

    /**
     * @brief Creates an instance (i.e. an actual object) given the current
     * definition.
     *
     * Since this function is similar to a factory function,
     * it transfers the ownership of the object to the caller,
     * hence a unique_ptr is returned.
     *
     * @param name The name of the object to create
     * @return
     */
    GT_DATAMODEL_EXPORT
    std::unique_ptr<GtPropertyStructInstance> newInstance(QString name) const;


private:
    struct MemberType
    {
        QString id;
        PropertyFactoryFunction makeProperty;
    };

    std::vector<MemberType> members;
    QString instanceTypeName;
};

/**
 * @brief A container containing of a dynamic number of PropertyStructs
 * of specified types.
 */
class GtPropertyStructContainer
{
public:
    /**
     * @brief registerAllowedType
     * @param typeID
     * @param f
     */
    GT_DATAMODEL_EXPORT
    void registerAllowedType(QString typeID, GtPropertyStructDefinition f);

    /**
     * @brief Performs an in-place creation of a new struct instance
     * given the type.
     *
     * @param Name/id of the entry to create
     * @param typeID The typename / classname of the struct to create
     * @return
     */
    GT_DATAMODEL_EXPORT
    GtPropertyStructInstance& newEntry(QString name, QString typeID);

    /**
     * @brief Returns the number of entries in the vector
     */
    size_t size() const
    {
        return m_entries.size();
    }

    /**
     * @brief returns an iterator to the beginning
     */
    gt::poly_vector<GtPropertyStructInstance>::iterator begin()
    {
        return m_entries.begin();
    }

    /**
     * @brief returns an iterator to the beginning
     */
    gt::poly_vector<GtPropertyStructInstance>::const_iterator begin() const
    {
        return m_entries.begin();
    }

    /**
     * @brief returns an iterator to the end
     */
    gt::poly_vector<GtPropertyStructInstance>::iterator end()
    {
        return m_entries.end();
    }

    /**
     * @brief returns an iterator to the end
     */
    gt::poly_vector<GtPropertyStructInstance>::const_iterator end() const
    {
        return m_entries.end();
    }

    /**
     * @brief access specified element
     *
     * Returns a reference to the element at specified location pos.
     * No bounds checking is performed.
     *
     * @param idx position of the element to return
     * @return Reference to the requested element.
     */
    GtPropertyStructInstance& operator[](size_t idx)
    {
        return m_entries[idx];
    }

    /**
     * @brief access specified element
     *
     * Returns a reference to the element at specified location pos.
     * No bounds checking is performed.
     *
     * @param idx position of the element to return
     * @return Reference to the requested element.
     */
    const GtPropertyStructInstance& operator[](size_t idx) const
    {
        return m_entries[idx];
    }

    /**
     * @brief access specified element with bounds checking
     *
     * Returns a reference to the element at specified location pos,
     * with bounds checking. If pos is not within the range of the container,
     * an exception of type std::out_of_range is thrown.
     *
     * @param idx position of the element to return
     * @return Reference to the requested element.
     */
    GtPropertyStructInstance& at(size_t idx)
    {
        return m_entries.at(idx);
    }

    /**
     * @brief access specified element with bounds checking
     *
     * Returns a reference to the element at specified location pos,
     * with bounds checking. If pos is not within the range of the container,
     * an exception of type std::out_of_range is thrown.
     *
     * @param idx position of the element to return
     * @return Reference to the requested element.
     */
    const GtPropertyStructInstance& at(size_t idx) const
    {
        return m_entries.at(idx);
    }

private:
    using TypeIdStr = QString;
    std::map<TypeIdStr, GtPropertyStructDefinition> allowedTypes;

    gt::poly_vector<GtPropertyStructInstance> m_entries;
};


#endif // GTDYNAMICPROPERTYCONTAINER_H
